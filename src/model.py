
"""
LCA Environmental and Circularity Prediction Model

This module provides functions to predict environmental and circularity indicators
for metals based on input parameters using a trained machine learning model.

Author: Generated by ML Pipeline
Date: 2025-09-28 20:55:43
Model: Random Forest
Performance: R² = 0.4513, RMSE = 14.8471
"""

import pandas as pd
import numpy as np
import joblib
import os
from typing import Dict, List, Optional, Union, Tuple

class LCAPredictor:
    """
    LCA Environmental and Circularity Predictor

    This class loads a trained machine learning model and provides methods
    to predict environmental and circularity indicators for metals.
    """

    def __init__(self, model_dir: str = 'models'):
        """
        Initialize the LCA Predictor

        Args:
            model_dir (str): Directory containing the model files
        """
        self.model_dir = model_dir
        self.model = None
        self.label_encoders = None
        self.metadata = None
        self.feature_info = None
        self._load_model_components()

    def _load_model_components(self):
        """Load all model components from saved files"""
        try:
            # Load the trained model
            model_path = os.path.join(self.model_dir, 'lca_model.pkl')
            self.model = joblib.load(model_path)

            # Load label encoders
            encoders_path = os.path.join(self.model_dir, 'label_encoders.pkl')
            self.label_encoders = joblib.load(encoders_path)

            # Load model metadata
            metadata_path = os.path.join(self.model_dir, 'model_metadata.pkl')
            self.metadata = joblib.load(metadata_path)

            # Load feature information
            feature_info_path = os.path.join(self.model_dir, 'feature_info.pkl')
            self.feature_info = joblib.load(feature_info_path)

            print("✅ Model components loaded successfully!")
            print(f"   Model type: {self.metadata['model_type']}")
            print(f"   Performance: R² = {self.metadata['average_test_r2']:.4f}")
            print(f"   Features: {len(self.metadata['feature_columns'])}")
            print(f"   Targets: {len(self.metadata['target_columns'])}")

        except Exception as e:
            raise Exception(f"Error loading model components: {str(e)}")

    def get_available_options(self) -> Dict[str, List[str]]:
        """
        Get available options for categorical inputs

        Returns:
            Dict containing available options for each categorical feature
        """
        options = {}
        for feature, encoder in self.label_encoders.items():
            options[feature] = encoder.classes_.tolist()
        return options

    def predict_single(self, 
                      metal: str, 
                      process_type: str, 
                      end_of_life: str,
                      **optional_params) -> Dict[str, float]:
        """
        Predict environmental and circularity indicators for a single metal sample

        Args:
            metal (str): Metal type (e.g., 'Steel', 'Aluminium', 'Copper')
            process_type (str): Process type (e.g., 'Primary', 'Recycled', 'Hybrid')
            end_of_life (str): End of life treatment (e.g., 'Landfilled', 'Recycled', 'Reused')
            **optional_params: Optional parameters for other features

        Returns:
            Dict containing predicted values for all environmental and circularity indicators
        """
        # Create input dataframe
        input_data = {
            'Metal': metal,
            'Process_Type': process_type,
            'End_of_Life': end_of_life
        }

        # Add optional parameters
        input_data.update(optional_params)

        # Create DataFrame with all required features
        feature_columns = self.metadata['feature_columns']
        df_input = pd.DataFrame([input_data])

        # Fill missing features with median values (you might want to improve this)
        for col in feature_columns:
            if col not in df_input.columns:
                if col in self.feature_info['numerical_features']:
                    df_input[col] = 0  # Default value for numerical features
                else:
                    # For categorical features, use the first available option
                    if col in self.label_encoders:
                        df_input[col] = self.label_encoders[col].classes_[0]
                    else:
                        df_input[col] = 'Unknown'

        # Reorder columns to match training data
        df_input = df_input[feature_columns]

        # Encode categorical variables
        df_encoded = df_input.copy()
        for col in self.feature_info['categorical_features']:
            if col in df_encoded.columns:
                try:
                    df_encoded[col] = self.label_encoders[col].transform(df_encoded[col].astype(str))
                except ValueError as e:
                    # Handle unknown categories
                    print(f"Warning: Unknown category in {col}. Using default value.")
                    df_encoded[col] = 0

        # Make prediction
        prediction = self.model.predict(df_encoded)

        # Create result dictionary
        result = {}
        target_columns = self.metadata['target_columns']

        for i, target in enumerate(target_columns):
            result[target] = float(prediction[0][i])

        return result

    def predict_batch(self, input_data: pd.DataFrame) -> pd.DataFrame:
        """
        Predict for multiple samples

        Args:
            input_data (pd.DataFrame): DataFrame containing input features

        Returns:
            pd.DataFrame: DataFrame with predictions
        """
        # Encode categorical variables
        df_encoded = input_data.copy()
        for col in self.feature_info['categorical_features']:
            if col in df_encoded.columns:
                df_encoded[col] = self.label_encoders[col].transform(df_encoded[col].astype(str))

        # Make predictions
        predictions = self.model.predict(df_encoded)

        # Create results DataFrame
        target_columns = self.metadata['target_columns']
        results_df = pd.DataFrame(predictions, columns=target_columns)

        return results_df

    def get_model_info(self) -> Dict:
        """Get information about the loaded model"""
        return {
            'model_type': self.metadata['model_type'],
            'performance': {
                'average_r2': self.metadata['average_test_r2'],
                'average_rmse': self.metadata['average_test_rmse']
            },
            'training_info': {
                'training_date': self.metadata['training_date'],
                'training_samples': self.metadata['training_samples'],
                'test_samples': self.metadata['test_samples']
            },
            'features': {
                'total_features': len(self.metadata['feature_columns']),
                'categorical_features': self.feature_info['categorical_features'],
                'numerical_features': self.feature_info['numerical_features']
            },
            'targets': {
                'environmental': self.metadata['environmental_targets'],
                'circularity': self.metadata['circularity_targets']
            }
        }


# Convenience functions for backward compatibility
def predict_lca_indicators(metal: str, 
                          process_type: str, 
                          end_of_life: str,
                          **optional_params) -> Dict[str, float]:
    """
    Convenience function to predict LCA indicators

    Args:
        metal (str): Metal type
        process_type (str): Process type
        end_of_life (str): End of life treatment
        **optional_params: Optional additional parameters

    Returns:
        Dict containing predicted environmental and circularity values
    """
    predictor = LCAPredictor()
    return predictor.predict_single(metal, process_type, end_of_life, **optional_params)


def get_available_metals() -> List[str]:
    """Get list of available metal types"""
    predictor = LCAPredictor()
    return predictor.get_available_options()['Metal']


def get_available_processes() -> List[str]:
    """Get list of available process types"""
    predictor = LCAPredictor()
    return predictor.get_available_options()['Process_Type']


def get_available_end_of_life() -> List[str]:
    """Get list of available end of life treatments"""
    predictor = LCAPredictor()
    return predictor.get_available_options()['End_of_Life']


# Example usage
if __name__ == "__main__":
    # Initialize predictor
    predictor = LCAPredictor()

    # Get available options
    options = predictor.get_available_options()
    print("Available options:")
    for key, values in options.items():
        print(f"  {key}: {values}")

    # Example prediction
    result = predictor.predict_single(
        metal="Steel",
        process_type="Recycled", 
        end_of_life="Recycled"
    )

    print("\nExample prediction for Steel (Recycled, Recycled):")
    print("Environmental indicators:")
    for target in predictor.metadata['environmental_targets']:
        print(f"  {target}: {result[target]:.4f}")

    print("\nCircularity indicators:")
    for target in predictor.metadata['circularity_targets']:
        print(f"  {target}: {result[target]:.4f}")
